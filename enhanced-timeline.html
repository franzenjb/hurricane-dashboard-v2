<!DOCTYPE html>
<html>
<head>
    <title>Atlantic Hurricane Timeline - Two Line Banner v2</title>
    <!-- Cache busting: 2025-08-18 8:42 PM -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="atlantic-storms-enhanced.js"></script>
    <script src="storm-surge-layer.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; overflow: hidden; }
        .container { display: flex; height: 100vh; width: 100vw; }
        .left-sidebar { width: 80px; background: #e0e0e0; padding: 15px; display: flex; flex-direction: column; align-items: center; border-right: 1px solid #ccc; position: relative; }
        .main-content { flex: 1; display: flex; flex-direction: column; min-width: 0; }
        .right-sidebar { width: 525px; background: #f5f5f5; border-left: 2px solid #ccc; display: flex; flex-direction: column; }
        .top-controls { padding: 10px 20px; background: #f8f8f8; border-bottom: 1px solid #ddd; }
        .header-row { display: flex; align-items: center; justify-content: flex-start; flex-wrap: nowrap; gap: 20px; }
        .controls-section { display: flex; align-items: center; gap: 15px; flex-wrap: nowrap; }
        .category-group { display: flex; align-items: center; gap: 8px; }
        .category-group label { font-size: 13px; font-weight: bold; margin-right: 5px; }
        .category-checkboxes { display: flex; gap: 8px; }
        .category-checkboxes label { font-size: 12px; white-space: nowrap; }
        .search-input { padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; width: 140px; }
        .filter-button { padding: 6px 12px; border: 1px solid #007cba; background: #007cba; color: white; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .clear-button { padding: 6px 12px; border: 1px solid #666; background: #666; color: white; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .chart-container { flex: 1; position: relative; min-height: 400px; }
        .vertical-year-slider { position: absolute; left: 25px; top: 60px; bottom: 60px; width: 30px; }
        .vertical-track { position: relative; width: 8px; height: 100%; background: #ddd; border-radius: 4px; margin: 0 auto; }
        .vertical-range { position: absolute; width: 8px; background: #007cba; border-radius: 4px; cursor: grab; }
        .vertical-range:active { cursor: grabbing; }
        .vertical-handle { position: absolute; width: 24px; height: 24px; background: #007cba; border: 3px solid white; border-radius: 50%; cursor: grab; left: -8px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .vertical-handle:active { cursor: grabbing; }
        .year-label { position: absolute; left: 40px; font-size: 12px; font-weight: bold; color: #333; transform: translateY(-50%); width: 40px; text-align: center; }
        #timeline { width: 100%; height: 100%; min-height: 400px; }
        .popup { position: fixed; top: 20px; right: 20px; width: 300px; background: white; border: 2px solid #333; border-radius: 8px; padding: 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.3); z-index: 1000; display: none; }
        .popup h3 { margin: 0 0 10px 0; color: #333; }
        .popup .close { position: absolute; top: 10px; right: 15px; font-size: 24px; cursor: pointer; }
        .popup .details { line-height: 1.5; }
        .popup .details div { margin: 5px 0; }
        .storm-info-panel { flex: 0 0 12%; background: white; padding: 15px; overflow: hidden; }
        .storm-banner { display: flex; flex-direction: column; gap: 8px; }
        .storm-name-section { display: flex; align-items: center; gap: 15px; }
        .category-icon { width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; font-size: 20px; flex-shrink: 0; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
        .storm-title { font-size: 24px; font-weight: bold; color: #333; white-space: nowrap; }
        .stats-inline { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 8px; }
        .stat-inline { text-align: center; background: #f8f9fa; border-radius: 6px; padding: 8px 4px; }
        .stat-label { font-size: 10px; color: #666; text-transform: uppercase; margin-bottom: 3px; font-weight: 600; }
        .stat-value { font-size: 14px; font-weight: bold; color: #333; }
        .map-panel { flex: 0 0 43%; background: white; position: relative; }
        #map { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        .narrative-panel { flex: 0 0 45%; background: white; padding: 20px; overflow-y: auto; }
        .narrative-header { font-size: 18px; font-weight: bold; color: #333; margin-bottom: 10px; border-bottom: 2px solid #007cba; padding-bottom: 5px; }
        .narrative-subtitle { font-size: 12px; color: #666; margin-bottom: 15px; font-style: italic; }
        .narrative-content { font-size: 16px; line-height: 1.6; color: #555; }
        
        /* Legend styles */
        .map-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            z-index: 1000;
            font-size: 12px;
        }
        
        .legend-title {
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 4px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 4px 0;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-sidebar">
            <div style="margin-bottom: 20px; font-size: 12px; font-weight: bold;">Years</div>
            <div class="vertical-year-slider">
                <div class="vertical-track">
                    <div class="vertical-range" id="verticalRange"></div>
                    <div class="vertical-handle" id="topHandle"></div>
                    <div class="vertical-handle" id="bottomHandle"></div>
                </div>
                <div class="year-label" id="topYearLabel" style="top: 0;">2010</div>
                <div class="year-label" id="bottomYearLabel" style="bottom: 0;">2024</div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="top-controls">
                <div class="header-row">
                    <div class="controls-section">
                        <input type="text" id="nameFilter" placeholder="Search by name" class="search-input">
                        <div class="category-group">
                            <label>Categories:</label>
                            <div class="category-checkboxes" id="categoryFilter">
                                <label><input type="checkbox" value="0"> TS</label>
                                <label><input type="checkbox" value="1"> Cat 1</label>
                                <label><input type="checkbox" value="2"> Cat 2</label>
                                <label><input type="checkbox" value="3" checked> Cat 3</label>
                                <label><input type="checkbox" value="4" checked> Cat 4</label>
                                <label><input type="checkbox" value="5" checked> Cat 5</label>
                            </div>
                        </div>
                        <label><input type="checkbox" id="landfallOnly"> Landfall Only</label>
                        <button onclick="applyFilters()" class="filter-button">Apply Filters</button>
                        <button onclick="clearFilters()" class="clear-button">Clear</button>
                    </div>
                </div>
            </div>
            
            <div class="chart-container">
                <div id="timeline"></div>
            </div>
            
        </div>
        
        <div class="right-sidebar">
            <div class="storm-info-panel" id="stormInfoPanel">
                <div class="storm-banner">
                    <div class="storm-name-section">
                        <div class="category-icon" id="categoryIcon" style="background-color: #8B9DC3;">TS</div>
                        <div class="storm-title" id="stormTitle">Select a Storm</div>
                    </div>
                    <div class="stats-inline">
                        <div class="stat-inline">
                            <div class="stat-label">Date</div>
                            <div class="stat-value" id="statDate">-</div>
                        </div>
                        <div class="stat-inline">
                            <div class="stat-label">Wind</div>
                            <div class="stat-value" id="statWind">-</div>
                        </div>
                        <div class="stat-inline">
                            <div class="stat-label">Landfall</div>
                            <div class="stat-value" id="statLandfall">-</div>
                        </div>
                        <div class="stat-inline">
                            <div class="stat-label">Deaths</div>
                            <div class="stat-value" id="statDeaths">-</div>
                        </div>
                    </div>
                    <div style="margin-top: 10px;">
                        <button onclick="toggleSurgeVisualization()" style="width: 100%; padding: 8px; background: #007cba; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: bold;">
                            🌊 Toggle Storm Surge
                        </button>
                    </div>
                    <div style="margin-top: 8px;">
                        <button id="animateBtn" onclick="toggleStormAnimation()" style="width: 100%; padding: 8px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: bold;">
                            ▶️ Animate Storm Track
                        </button>
                    </div>
                    <div id="animationControls" style="display: none; margin-top: 8px;">
                        <input type="range" id="animationSpeed" min="50" max="1000" value="500" style="width: 100%;">
                        <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666;">
                            <span>Slow</span>
                            <span>Speed</span>
                            <span>Fast</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="map-panel">
                <div id="map"></div>
                <div class="map-legend">
                    <div class="legend-title">Hurricane Categories</div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #8B9DC3;"></div>
                        <span>TS - Tropical Storm</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #5CB85C;"></div>
                        <span>Cat 1 (74-95 mph)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #F0AD4E;"></div>
                        <span>Cat 2 (96-110 mph)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #FF7F00;"></div>
                        <span>Cat 3 (111-129 mph)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #D9534F;"></div>
                        <span>Cat 4 (130-156 mph)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #8B008B;"></div>
                        <span>Cat 5 (≥157 mph)</span>
                    </div>
                </div>
            </div>
            <div class="narrative-panel" id="narrativePanel">
                <div class="narrative-header">Historical Narrative</div>
                <div class="narrative-subtitle">Select a storm with landfall history for detailed narrative information.</div>
                <div class="narrative-content" id="narrativeContent">
                </div>
            </div>
        </div>
    </div>
    
    <div id="stormPopup" class="popup">
        <span class="close" onclick="closePopup()">&times;</span>
        <h3 id="popupTitle">Storm Details</h3>
        <div id="popupContent" class="details"></div>
    </div>
    
    <script>
        // Use the enhanced static data with multi-state landfalls and narratives
        let filteredStorms = [...ATLANTIC_STORMS_ENHANCED];
        
        function getCategoryColor(category) {
            const colors = {
                0: "#8B9DC3", 1: "#5CB85C", 2: "#F0AD4E", 
                3: "#FF7F00", 4: "#D9534F", 5: "#8B008B"
            };
            return colors[category] || "#757575";
        }
        
        // Enhanced landfall detection using analyzed track data
        function isLikelyUSLandfall(storm) {
            // Use the enhanced landfall_states array if available
            if (storm.landfall_states && Array.isArray(storm.landfall_states)) {
                return storm.landfall_states.length > 0;
            }
            
            // Fallback to coordinate-based detection for older data
            if (!storm.lat || !storm.lon) return false;
            
            // Atlantic basin US landfall areas only
            const ATLANTIC_US_LANDFALL_BOUNDS = {
                // East Coast: Maine to Florida Keys
                eastCoast: {
                    north: 47.5, south: 24.3, east: -66.0, west: -87.0
                },
                // Gulf Coast: Florida to Texas (Atlantic storms that enter Gulf)
                gulfCoast: {
                    north: 32.0, south: 24.0, east: -80.0, west: -98.0
                },
                // Puerto Rico and US Virgin Islands (Atlantic territories)
                caribbeanTerritories: {
                    north: 18.6, south: 17.6, east: -64.5, west: -67.5
                }
            };
            
            const lat = storm.lat;
            const lon = storm.lon;
            
            // Check if coordinates fall within Atlantic basin US landfall zones
            const inEastCoast = (lat >= ATLANTIC_US_LANDFALL_BOUNDS.eastCoast.south && 
                               lat <= ATLANTIC_US_LANDFALL_BOUNDS.eastCoast.north &&
                               lon >= ATLANTIC_US_LANDFALL_BOUNDS.eastCoast.west && 
                               lon <= ATLANTIC_US_LANDFALL_BOUNDS.eastCoast.east);
                               
            const inGulfCoast = (lat >= ATLANTIC_US_LANDFALL_BOUNDS.gulfCoast.south && 
                               lat <= ATLANTIC_US_LANDFALL_BOUNDS.gulfCoast.north &&
                               lon >= ATLANTIC_US_LANDFALL_BOUNDS.gulfCoast.west && 
                               lon <= ATLANTIC_US_LANDFALL_BOUNDS.gulfCoast.east);
                               
            const inCaribbean = (lat >= ATLANTIC_US_LANDFALL_BOUNDS.caribbeanTerritories.south && 
                               lat <= ATLANTIC_US_LANDFALL_BOUNDS.caribbeanTerritories.north &&
                               lon >= ATLANTIC_US_LANDFALL_BOUNDS.caribbeanTerritories.west && 
                               lon <= ATLANTIC_US_LANDFALL_BOUNDS.caribbeanTerritories.east);
            
            return inEastCoast || inGulfCoast || inCaribbean;
        }
        
        function updateStormInfoPanel(storm) {
            const panel = document.getElementById('stormInfoPanel');
            const icon = document.getElementById('categoryIcon');
            const title = document.getElementById('stormTitle');
            
            // Update header
            title.textContent = storm.name;
            icon.textContent = storm.category === 0 ? 'TS' : storm.category;
            icon.style.backgroundColor = getCategoryColor(storm.category);
            
            // Update stats using static data
            document.getElementById('statDate').textContent = `${getMonthName(storm.month)} ${storm.day}, ${storm.year}`;
            document.getElementById('statWind').textContent = `${storm.wind_mph} mph`;
            // Show landfall states (enhanced data)
            if (storm.landfall_states && storm.landfall_states.length > 0) {
                document.getElementById('statLandfall').textContent = storm.landfall_states.join(', ');
            } else {
                document.getElementById('statLandfall').textContent = 'No US Landfall';
            }
            document.getElementById('statDeaths').textContent = storm.deaths || '0';
            
            // Update narrative panel
            const narrativeContent = document.getElementById('narrativeContent');
            if (storm.narrative) {
                narrativeContent.textContent = storm.narrative;
            } else {
                narrativeContent.textContent = `${storm.name} was a ${storm.category === 0 ? 'tropical storm' : `Category ${storm.category} hurricane`} that occurred in ${storm.year}. This storm did not make landfall in U.S. territory, so no detailed impact narrative is available.`;
            }
        }
        
        function createTimeline() {
            console.log('Creating timeline with', filteredStorms.length, 'storms');
            
            // IMPORTANT: Atlantic Hurricane Timeline Axis Convention
            // X-axis = MONTHS (horizontal: Jun, Jul, Aug, Sep, Oct, Nov)
            // Y-axis = HURRICANE SEASON YEAR (vertical: June storms near year mark, December storms near next year)
            // This spreads the 7-month season across the full vertical space between year marks
            
            const traces = [{
                x: filteredStorms.map(s => s.month + (s.day - 1) / 31), // Position within month based on day
                y: filteredStorms.map(s => s.year + (s.month - 6 + (s.day - 1) / 31) / 7), // Position within hurricane season (Jun=0, Dec=1)
                text: filteredStorms.map(s => s.name),
                mode: 'markers+text',
                type: 'scatter',
                textposition: 'top center',
                marker: {
                    size: filteredStorms.map(s => 10 + s.wind_mph / 10),
                    color: filteredStorms.map(s => getCategoryColor(s.category)),
                    line: { color: 'white', width: 2 }
                },
                hovertemplate: '<b>%{text}</b><br>Date: %{customdata[2]}<br>Year: %{customdata[3]}<br>Category: %{customdata[0]}<br>Wind: %{customdata[1]} mph<extra></extra>',
                customdata: filteredStorms.map(s => [
                    s.category === 0 ? 'TS' : s.category, 
                    s.wind_mph,
                    `${getMonthName(s.month)} ${s.day}`,
                    s.year  // Add actual year as 4th element to avoid decimal positioning values
                ])
            }];
            
            // Calculate EXPLICIT tick values for Y-axis (MAXIMUM 15 lines)
            const yearRange = yearMax - yearMin;
            const maxLines = 15;
            
            // Calculate interval ensuring we never exceed maxLines
            let interval = Math.max(2, Math.ceil(yearRange / maxLines));
            
            // Round to nice intervals
            if (yearRange <= 15) interval = 1;
            else if (yearRange <= 30) interval = 2;
            else if (yearRange <= 75) interval = 5;
            else if (yearRange <= 150) interval = 10;
            else if (yearRange <= 300) interval = 20;
            else interval = 50;
            
            // Generate explicit tick values
            const tickValues = [];
            const startTick = Math.ceil(yearMin / interval) * interval;
            for (let year = startTick; year <= yearMax; year += interval) {
                tickValues.push(year);
            }
            
            // Safety check: if still too many ticks, increase interval
            if (tickValues.length > maxLines) {
                interval *= 2;
                tickValues.length = 0;
                const newStartTick = Math.ceil(yearMin / interval) * interval;
                for (let year = newStartTick; year <= yearMax; year += interval) {
                    tickValues.push(year);
                }
            }
            
            console.log(`Year range: ${yearRange}, interval: ${interval}, tick count: ${tickValues.length}, ticks:`, tickValues);
            
            const layout = {
                title: 'Atlantic Hurricane Timeline',
                xaxis: { 
                    title: 'Month',
                    tickvals: [6,7,8,9,10,11,12],
                    ticktext: ['Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
                    range: [5.7, 12.3]
                },
                yaxis: { 
                    title: 'Year',
                    autorange: false,
                    range: [yearMax + 1, yearMin - 1],
                    tickmode: 'array',
                    tickvals: tickValues,
                    showgrid: true,
                    gridwidth: 1
                },
                hovermode: 'closest',
                autosize: true,
                margin: { l: 60, r: 40, t: 60, b: 60 }
            };
            
            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };
            
            Plotly.newPlot('timeline', traces, layout, config);
            
            // Add click handler for storm details
            const timelineDiv = document.getElementById('timeline');
            timelineDiv.on('plotly_click', function(data){
                if (!data || !data.points || data.points.length === 0) return;
                console.log('Storm clicked:', data);
                const pointIndex = data.points[0].pointIndex;
                const storm = filteredStorms[pointIndex];
                if (storm) {
                    console.log('Selected storm:', storm.name, storm.year);
                    updateStormInfoPanel(storm);
                    showStormOnMap(storm);
                }
            });
        }
        
        function showStormDetails(storm) {
            const popup = document.getElementById('stormPopup');
            const title = document.getElementById('popupTitle');
            const content = document.getElementById('popupContent');
            
            title.textContent = `Hurricane ${storm.name} (${storm.year})`;
            content.innerHTML = `
                <div><strong>Date:</strong> ${getMonthName(storm.month)} ${storm.day}, ${storm.year}</div>
                <div><strong>Category:</strong> ${storm.category === 0 ? 'Tropical Storm' : 'Category ' + storm.category}</div>
                <div><strong>Wind Speed:</strong> ${storm.wind_mph} mph</div>
                <div><strong>Landfall States:</strong> ${storm.landfall_states && storm.landfall_states.length > 0 ? storm.landfall_states.join(', ') : 'No US Landfall'}</div>
                ${storm.deaths ? `<div><strong>Deaths:</strong> ${storm.deaths}</div>` : ''}
                ${storm.lat && storm.lon ? `<div><strong>Location:</strong> ${storm.lat.toFixed(2)}°N, ${Math.abs(storm.lon).toFixed(2)}°W</div>` : ''}
                ${storm.narrative ? `<div style="margin-top: 15px;"><strong>Historical Narrative:</strong><br><em>${storm.narrative}</em></div>` : ''}
            `;
            
            popup.style.display = 'block';
            showStormOnMap(storm);
        }
        
        function closePopup() {
            document.getElementById('stormPopup').style.display = 'none';
        }
        
        function getMonthName(month) {
            const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            return months[month-1];
        }
        
        // Vertical year range slider variables
        let yearMin = 2010;
        let yearMax = new Date().getFullYear();
        let isDragging = false;
        let activeHandle = null;
        let isDraggingRange = false;
        let dragStartY = 0;
        let dragStartYearMin = 0;
        let dragStartYearMax = 0;
        
        // Extract updateVerticalSliderDisplay to global scope for use by applyFilters
        function updateVerticalSliderDisplay() {
            const topHandle = document.getElementById('topHandle');
            const bottomHandle = document.getElementById('bottomHandle');
            const range = document.getElementById('verticalRange');
            
            if (!topHandle || !bottomHandle || !range) return; // Guards for when elements don't exist yet
            
            const topPercent = (yearMin - 1851) / (2025 - 1851) * 100;
            const bottomPercent = (yearMax - 1851) / (2025 - 1851) * 100;
            
            topHandle.style.top = topPercent + '%';
            bottomHandle.style.top = bottomPercent + '%';
            range.style.top = topPercent + '%';
            range.style.height = (bottomPercent - topPercent) + '%';
            
            document.getElementById('topYearLabel').textContent = yearMin;
            document.getElementById('bottomYearLabel').textContent = yearMax;
        }

        function initVerticalYearSlider() {
            const topHandle = document.getElementById('topHandle');
            const bottomHandle = document.getElementById('bottomHandle');
            const range = document.getElementById('verticalRange');
            const track = document.querySelector('.vertical-track');
            
            updateVerticalSliderDisplay();
            
            function getYearFromPosition(y) {
                const rect = track.getBoundingClientRect();
                const percent = Math.max(0, Math.min(1, (y - rect.top) / rect.height));
                // Convert position to year (1851 at top = 0%, 2025 at bottom = 100%)
                return Math.round(1851 + percent * (2025 - 1851));
            }
            
            topHandle.addEventListener('mousedown', (e) => {
                isDragging = true;
                activeHandle = 'top';
                e.preventDefault();
            });
            
            bottomHandle.addEventListener('mousedown', (e) => {
                isDragging = true;
                activeHandle = 'bottom';
                e.preventDefault();
            });
            
            // Add drag functionality to the range area (between handles)
            range.addEventListener('mousedown', (e) => {
                isDraggingRange = true;
                dragStartY = e.clientY;
                dragStartYearMin = yearMin;
                dragStartYearMax = yearMax;
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const newYear = getYearFromPosition(e.clientY);
                    
                    if (activeHandle === 'top') {
                        yearMin = Math.min(newYear, yearMax - 5); // Keep at least 5 year gap
                    } else if (activeHandle === 'bottom') {
                        yearMax = Math.max(newYear, yearMin + 5); // Keep at least 5 year gap
                    }
                    
                    // Ensure bounds
                    yearMin = Math.max(1851, yearMin);
                    yearMax = Math.min(2025, yearMax);
                    
                    updateVerticalSliderDisplay();
                    applyFilters();
                } else if (isDraggingRange) {
                    // Calculate the year change based on mouse movement
                    const rect = track.getBoundingClientRect();
                    const deltaY = e.clientY - dragStartY;
                    const deltaPercent = deltaY / rect.height;
                    const deltaYears = deltaPercent * (2025 - 1851);
                    
                    const yearRange = dragStartYearMax - dragStartYearMin;
                    let newYearMin = dragStartYearMin + deltaYears;
                    let newYearMax = dragStartYearMax + deltaYears;
                    
                    // Ensure bounds - keep the range together
                    if (newYearMin < 1851) {
                        newYearMin = 1851;
                        newYearMax = newYearMin + yearRange;
                    }
                    if (newYearMax > 2025) {
                        newYearMax = 2025;
                        newYearMin = newYearMax - yearRange;
                    }
                    
                    yearMin = Math.round(newYearMin);
                    yearMax = Math.round(newYearMax);
                    
                    updateVerticalSliderDisplay();
                    applyFilters();
                }
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
                isDraggingRange = false;
                activeHandle = null;
            });
        }
        
        function applyFilters() {
            const nameFilter = document.getElementById('nameFilter').value.toLowerCase();
            const landfallOnly = document.getElementById('landfallOnly').checked;
            
            // Get selected categories from checkboxes
            const selectedCategories = [];
            const categoryCheckboxes = document.querySelectorAll('#categoryFilter input[type="checkbox"]:checked');
            categoryCheckboxes.forEach(checkbox => {
                selectedCategories.push(parseInt(checkbox.value));
            });
            
            filteredStorms = ATLANTIC_STORMS_ENHANCED.filter(storm => {
                // If name search is active, ONLY filter by name - ignore all other filters
                if (nameFilter) {
                    return storm.name.toLowerCase().includes(nameFilter);
                }
                
                // Otherwise apply normal filters
                if (selectedCategories.length > 0 && !selectedCategories.includes(storm.category)) return false;
                if (storm.year < yearMin || storm.year > yearMax) return false;
                // Only show hurricane season months (Jun-Dec: months 6-12)
                if (storm.month < 6 || storm.month > 12) return false;
                // Filter for landfall storms if checkbox is checked
                if (landfallOnly && !isLikelyUSLandfall(storm)) return false;
                return true;
            });
            
            // If name search is active and found storms, adjust year slider to show results
            if (nameFilter && filteredStorms.length > 0) {
                const stormYears = filteredStorms.map(s => s.year);
                const minStormYear = Math.min(...stormYears);
                const maxStormYear = Math.max(...stormYears);
                
                // Only adjust if storms are outside current range
                if (minStormYear < yearMin || maxStormYear > yearMax) {
                    yearMin = Math.min(minStormYear, yearMin);
                    yearMax = Math.max(maxStormYear, yearMax);
                    
                    // Update visual slider display
                    updateVerticalSliderDisplay();
                    
                    console.log(`Name search found storms from ${minStormYear}-${maxStormYear}, adjusted slider to ${yearMin}-${yearMax}`);
                }
            }
            
            // IMPORTANT: Do NOT plot all filtered storms on the map
            // The map should only show the currently selected storm's path
            // Clear the map but keep the current storm if one is selected
            if (currentStorm) {
                clearMapLayers();
                showStormOnMap(currentStorm);
            }
            
            createTimeline();
        }
        
        function clearFilters() {
            document.getElementById('nameFilter').value = '';
            
            // Reset category checkboxes to initial page load state (only Cat 3-5)
            const categoryCheckboxes = document.querySelectorAll('#categoryFilter input[type="checkbox"]');
            categoryCheckboxes.forEach(checkbox => {
                const category = parseInt(checkbox.value);
                checkbox.checked = (category >= 3); // Only Cat 3, 4, 5 checked by default
            });
            
            // Reset landfall filter
            document.getElementById('landfallOnly').checked = false;
            
            // Reset year range
            yearMin = 2010;
            yearMax = new Date().getFullYear();
            
            // Close any open popup (keep storm info panel always visible)
            document.getElementById('stormPopup').style.display = 'none';
            
            // Reset map view
            if (map) {
                clearMapLayers();
                map.setView([25.0, -80.0], 5);
            }
            
            // Update vertical slider display
            const topHandle = document.getElementById('topHandle');
            const bottomHandle = document.getElementById('bottomHandle');
            const range = document.getElementById('verticalRange');
            
            if (topHandle && bottomHandle && range) {
                const topPercent = (yearMin - 1851) / (2025 - 1851) * 100;
                const bottomPercent = (yearMax - 1851) / (2025 - 1851) * 100;
                
                topHandle.style.top = topPercent + '%';
                bottomHandle.style.top = bottomPercent + '%';
                range.style.top = topPercent + '%';
                range.style.height = (bottomPercent - topPercent) + '%';
                
                document.getElementById('topYearLabel').textContent = yearMin;
                document.getElementById('bottomYearLabel').textContent = yearMax;
            }
            
            applyFilters();
        }
        
        // Initialize map
        let map;
        let surgeLayer = null;
        
        function initMap() {
            console.log('Initializing Leaflet map...');
            const mapDiv = document.getElementById('map');
            if (!mapDiv) {
                console.error('Map div not found!');
                return;
            }
            
            // Set explicit height for the map div
            mapDiv.style.height = '100%';
            mapDiv.style.width = '100%';
            
            map = L.map('map').setView([28.0, -75.0], 5); // Better Atlantic basin view
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 18
            }).addTo(map);
            
            // Initialize storm surge layer
            if (typeof StormSurgeLayer !== 'undefined') {
                surgeLayer = new StormSurgeLayer(map);
                console.log('Storm surge layer initialized');
            }
            
            console.log('Map initialized successfully');
        }
        
        let currentStorm = null;
        let currentTrackData = null;
        let animationRunning = false;
        let animationFrame = null;
        let animatedMarker = null;
        
        function toggleSurgeVisualization() {
            if (!surgeLayer || !currentStorm) return;
            
            surgeLayer.toggle(currentStorm);
        }
        
        async function showStormOnMap(storm) {
            if (!map) return;
            
            currentStorm = storm;
            clearMapLayers();
            console.log('=== STORM DEBUG INFO ===');
            console.log('Storm object:', storm);
            console.log('Storm name:', storm.name);
            console.log('Storm year:', storm.year);
            console.log('Storm ID:', storm.storm_id);
            console.log('Storm properties:', Object.keys(storm));
            
            // Try to load the full storm track
            const trackData = await loadStormTrack(storm);
            currentTrackData = trackData; // Save for animation
            
            if (trackData) {
                console.log('Track data loaded, drawing storm track');
                // Draw the full storm track
                drawStormTrack(trackData, storm);
                // Enable animation button if we have track data
                document.getElementById('animateBtn').disabled = false;
            } else {
                document.getElementById('animateBtn').disabled = true;
                console.log('No track data found, showing single point');
                // Fallback to single point if no track data available
                if (storm.lat && storm.lon) {
                    const color = getCategoryColor(storm.category);
                    L.circleMarker([storm.lat, storm.lon], {
                        color: color,
                        fillColor: color,
                        fillOpacity: 0.7,
                        radius: 8
                    }).addTo(map).bindPopup(`<b>${storm.name}</b><br>Category ${storm.category}<br>${storm.wind_mph} mph`);
                    
                    map.setView([storm.lat, storm.lon], 6);
                }
            }
        }

        async function loadStormTrack(storm) {
            try {
                // Determine which decade file to load  
                const decade = Math.floor(storm.year / 10) * 10;
                
                // Try to load point data first (for category-based coloring)
                const pointsFile = `./hurdat2_data/points_${decade}s.geojson`;
                console.log(`=== TRACK LOADING DEBUG ===`);
                console.log(`Decade: ${decade}, File: ${pointsFile}`);
                console.log(`Looking for storm_id: "${storm.storm_id}"`);
                console.log(`Storm name: "${storm.name}", year: ${storm.year}`);
                
                let pointsResponse = await fetch(pointsFile);
                if (pointsResponse.ok) {
                    const pointsData = await pointsResponse.json();
                    console.log(`Loaded ${pointsData.features.length} total features from ${pointsFile}`);
                    
                    // Show first few storm_ids for comparison
                    const sampleIds = pointsData.features.slice(0, 5).map(f => f.properties.storm_id);
                    console.log(`Sample storm_ids in file:`, sampleIds);
                    
                    const pointFeatures = pointsData.features.filter(f => 
                        f.properties.storm_id === storm.storm_id
                    );
                    
                    console.log(`Found ${pointFeatures.length} matching features for storm_id "${storm.storm_id}"`);
                    
                    if (pointFeatures.length > 0) {
                        console.log(`SUCCESS: Found ${pointFeatures.length} track points for ${storm.name}`);
                        return { type: 'points', features: pointFeatures };
                    }
                }
                
                // Fallback to track lines
                const tracksFile = `./hurdat2_data/tracks_${decade}s.geojson`;
                console.log(`Loading track line from ${tracksFile} for storm ${storm.storm_id}`);
                
                const tracksResponse = await fetch(tracksFile);
                if (!tracksResponse.ok) {
                    console.log(`Track file ${tracksFile} not found`);
                    return null;
                }
                
                const tracksData = await tracksResponse.json();
                const feature = tracksData.features.find(f => 
                    f.properties.storm_id === storm.storm_id
                );
                
                if (feature && feature.geometry.type === 'LineString') {
                    console.log(`Found track line for ${storm.name} with ${feature.geometry.coordinates.length} points`);
                    return { type: 'line', geometry: feature.geometry };
                } else {
                    console.log(`No track found for storm ${storm.storm_id} (${storm.name})`);
                    return null;
                }
            } catch (error) {
                console.error('Error loading storm track:', error);
                return null;
            }
        }

        function drawStormTrack(trackData, storm) {
            if (trackData.type === 'points' && trackData.features) {
                // Draw rainbow-colored track using point data
                drawRainbowTrack(trackData.features, storm);
            } else if (trackData.type === 'line' && trackData.geometry) {
                // Draw simple line track
                drawSimpleTrack(trackData.geometry, storm);
            }
        }

        function drawRainbowTrack(pointFeatures, storm, animate = true) {
            if (pointFeatures.length === 0) return;
            
            // Sort points by time if datetime is available
            pointFeatures.sort((a, b) => {
                if (a.properties.datetime && b.properties.datetime) {
                    return new Date(a.properties.datetime) - new Date(b.properties.datetime);
                }
                return 0;
            });
            
            // Collect ALL coordinates for proper bounds calculation
            const allLatLngs = [];
            const segments = [];
            
            // Prepare segments first
            for (let i = 0; i < pointFeatures.length - 1; i++) {
                const point1 = pointFeatures[i];
                const point2 = pointFeatures[i + 1];
                
                const coord1 = point1.geometry.coordinates;
                const coord2 = point2.geometry.coordinates;
                
                // Debug category data
                if (i < 3) {
                    console.log(`${storm.name} point ${i} properties:`, point1.properties);
                    console.log(`Raw max_wind value: ${point1.properties.max_wind} (type: ${typeof point1.properties.max_wind})`);
                }
                
                // Calculate category from wind speed (GeoJSON only has max_wind in knots)
                const maxWind = point1.properties.max_wind || 0; // Wind in knots
                let category = 0;
                if (maxWind >= 137) category = 5;      // 157+ mph  
                else if (maxWind >= 113) category = 4; // 130-156 mph (JOSE 135mph = 117kt should be Cat 4)
                else if (maxWind >= 96) category = 3;  // 111-129 mph
                else if (maxWind >= 83) category = 2;  // 96-110 mph
                else if (maxWind >= 64) category = 1;  // 74-95 mph
                else category = 0;                     // <74 mph (TS/TD)
                
                const latLng1 = [coord1[1], coord1[0]]; // Convert [lon,lat] to [lat,lon]
                const latLng2 = [coord2[1], coord2[0]];
                
                // Add to bounds calculation
                allLatLngs.push(latLng1);
                if (i === pointFeatures.length - 2) allLatLngs.push(latLng2); // Add final point
                
                // Draw rainbow-colored line segment
                const segmentColor = getCategoryColor(category);
                if (i < 5) { // Debug first few segments
                    console.log(`Segment ${i}: wind=${maxWind}kt, category=${category}, color=${segmentColor}`);
                }
                
                // Store segment for animation or immediate drawing
                segments.push({
                    coords: [latLng1, latLng2],
                    color: segmentColor,
                    index: i
                });
            }
            
            // Fit map to show COMPLETE storm track within sidebar constraints
            if (allLatLngs.length > 0) {
                const bounds = L.latLngBounds(allLatLngs);
                // Use larger padding for constrained sidebar map to ensure full visibility
                map.fitBounds(bounds, { 
                    padding: [20, 20],
                    maxZoom: 8  // Prevent over-zooming on short tracks
                });
                console.log(`Fitted ${storm.name} track bounds:`, bounds.toBBoxString());
            }
            
            // Draw segments with animation if enabled
            if (animate && segments.length > 0) {
                let segmentIndex = 0;
                const animationSpeed = Math.max(20, 500 / segments.length); // Adjust speed based on segment count
                
                const animateSegment = () => {
                    if (segmentIndex < segments.length) {
                        const segment = segments[segmentIndex];
                        L.polyline(segment.coords, {
                            color: segment.color,
                            weight: 6,
                            opacity: 1.0
                        }).addTo(map);
                        
                        segmentIndex++;
                        setTimeout(animateSegment, animationSpeed);
                    }
                };
                
                // Start animation
                animateSegment();
            } else {
                // Draw all segments immediately if no animation
                segments.forEach(segment => {
                    L.polyline(segment.coords, {
                        color: segment.color,
                        weight: 6,
                        opacity: 1.0
                    }).addTo(map);
                });
            }
        }

        function drawSimpleTrack(trackGeometry, storm) {
            const coordinates = trackGeometry.coordinates;
            
            // Convert coordinates from [lon, lat] to [lat, lon] for Leaflet
            const trackPoints = coordinates.map(coord => [coord[1], coord[0]]);
            
            // Create the track line
            const trackLine = L.polyline(trackPoints, {
                color: getCategoryColor(storm.category),
                weight: 4,
                opacity: 0.8
            }).addTo(map);
            
            // Add start and end markers
            if (trackPoints.length > 0) {
                // Start marker (green)
                L.circleMarker(trackPoints[0], {
                    color: '#00ff00',
                    fillColor: '#00ff00',
                    fillOpacity: 0.8,
                    radius: 8
                }).addTo(map).bindPopup(`<b>${storm.name} START</b><br>${storm.year}`);
                
                // End marker (red)
                L.circleMarker(trackPoints[trackPoints.length - 1], {
                    color: '#ff0000',
                    fillColor: '#ff0000',
                    fillOpacity: 0.8,
                    radius: 8
                }).addTo(map).bindPopup(`<b>${storm.name} END</b><br>${storm.year}`);
            }
            
            // Fit map to track bounds with padding optimized for sidebar
            map.fitBounds(trackLine.getBounds(), { 
                padding: [20, 20],
                maxZoom: 8  // Prevent over-zooming for constrained sidebar map
            });
        }


        function updateStormInfoPanel(storm) {
            // Update category icon
            const categoryIcon = document.getElementById('categoryIcon');
            const color = getCategoryColor(storm.category);
            categoryIcon.style.backgroundColor = color;
            categoryIcon.textContent = storm.category === 0 ? 'TS' : `C${storm.category}`;
            
            // Update storm title
            document.getElementById('stormTitle').textContent = `${storm.name} (${storm.year})`;
            
            // Update stats
            document.getElementById('statDate').textContent = `${getMonthName(storm.month)} ${storm.day}`;
            document.getElementById('statWind').textContent = `${storm.wind_mph} mph`;
            document.getElementById('statLandfall').textContent = storm.landfall_states && storm.landfall_states.length > 0 
                ? storm.landfall_states.join(', ') 
                : 'None';
            document.getElementById('statDeaths').textContent = storm.deaths || '0';
            
            // Update narrative panel
            const narrativeContent = document.getElementById('narrativeContent');
            if (storm.narrative) {
                narrativeContent.innerHTML = `<p style="line-height: 1.6; color: #333;">${storm.narrative}</p>`;
            } else {
                narrativeContent.innerHTML = `<p style="color: #666; font-style: italic;">No historical narrative available for this storm.</p>`;
            }
        }

        function clearMapLayers() {
            if (map) {
                map.eachLayer(function (layer) {
                    if (layer instanceof L.CircleMarker || layer instanceof L.Polyline) {
                        map.removeLayer(layer);
                    }
                });
                
                // Also clear surge visualization
                if (surgeLayer) {
                    surgeLayer.clearSurge();
                }
            }
            
            // Stop animation if running
            if (animationRunning) {
                stopAnimation();
            }
        }
        
        // Animation Functions
        function toggleStormAnimation() {
            if (!currentTrackData || !currentTrackData.features) return;
            
            if (animationRunning) {
                stopAnimation();
            } else {
                startAnimation();
            }
        }
        
        function startAnimation() {
            if (!currentTrackData || !currentTrackData.features) return;
            
            animationRunning = true;
            updateAnimationButton();
            document.getElementById('animationControls').style.display = 'block';
            
            // Get point features
            const pointFeatures = currentTrackData.features.filter(f => 
                f.geometry.type === 'Point' && 
                f.properties.storm_id === currentStorm.storm_id
            );
            
            if (pointFeatures.length === 0) return;
            
            // Sort points by time
            pointFeatures.sort((a, b) => {
                if (a.properties.datetime && b.properties.datetime) {
                    return new Date(a.properties.datetime) - new Date(b.properties.datetime);
                }
                return 0;
            });
            
            // Clear existing tracks
            clearMapLayers();
            
            // Animate through points
            let currentIndex = 0;
            const speed = document.getElementById('animationSpeed').value;
            
            function animate() {
                if (!animationRunning || currentIndex >= pointFeatures.length) {
                    if (currentIndex >= pointFeatures.length) {
                        // Animation complete
                        stopAnimation();
                    }
                    return;
                }
                
                const point = pointFeatures[currentIndex];
                const coord = point.geometry.coordinates;
                const category = point.properties.category || 0;
                const color = getCategoryColor(category);
                const datetime = point.properties.datetime;
                
                // Create marker for current position
                const marker = L.circleMarker([coord[1], coord[0]], {
                    color: '#000',
                    weight: 2,
                    fillColor: color,
                    fillOpacity: 0.8,
                    radius: 10
                }).addTo(map);
                
                // Update popup
                let popupContent = `<b>${currentStorm.name}</b><br>`;
                if (datetime) {
                    const date = new Date(datetime);
                    popupContent += `${date.toLocaleString()}<br>`;
                }
                popupContent += `Category: ${category}<br>`;
                if (point.properties.wind_mph) {
                    popupContent += `Wind: ${point.properties.wind_mph} mph`;
                }
                marker.bindPopup(popupContent).openPopup();
                
                // Draw trail
                if (currentIndex > 0) {
                    const prevPoint = pointFeatures[currentIndex - 1];
                    const prevCoord = prevPoint.geometry.coordinates;
                    const prevCategory = prevPoint.properties.category || 0;
                    const prevColor = getCategoryColor(prevCategory);
                    
                    L.polyline([[prevCoord[1], prevCoord[0]], [coord[1], coord[0]]], {
                        color: prevColor,
                        weight: 3,
                        opacity: 0.7
                    }).addTo(map);
                }
                
                // Center map on current position
                map.setView([coord[1], coord[0]], map.getZoom());
                
                currentIndex++;
                
                // Schedule next frame
                animationFrame = setTimeout(() => {
                    animate();
                }, 1100 - speed); // Invert speed so higher value = faster
            }
            
            animate();
        }
        
        function stopAnimation() {
            animationRunning = false;
            if (animationFrame) {
                clearTimeout(animationFrame);
                animationFrame = null;
            }
            updateAnimationButton();
            document.getElementById('animationControls').style.display = 'none';
            
            // Redraw the full track
            if (currentTrackData && currentStorm) {
                drawStormTrack(currentTrackData, currentStorm);
            }
        }
        
        function updateAnimationButton() {
            const btn = document.getElementById('animateBtn');
            if (animationRunning) {
                btn.innerHTML = '⏸️ Pause Animation';
                btn.style.background = '#dc3545';
            } else {
                btn.innerHTML = '▶️ Animate Storm Track';
                btn.style.background = '#28a745';
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, applying initial filters...');
            initMap();
            initVerticalYearSlider();
            
            // Clear the map first to ensure no stray markers
            if (map) {
                clearMapLayers();
            }
            
            applyFilters(); // Use applyFilters() to respect default checkbox settings
        });
        
        // Handle messages from parent frame (Database tab integration)
        window.addEventListener('message', function(event) {
            // Security check - only accept messages from same origin
            if (event.origin !== window.location.origin) return;
            
            const data = event.data;
            
            switch(data.action) {
                case 'displayStorm':
                    // Display a single storm from Database tab
                    if (data.storm) {
                        clearMapLayers();
                        updateStormInfoPanel(data.storm);
                        showStormOnMap(data.storm);
                        console.log('Displaying storm from Database:', data.storm.name, data.storm.year);
                    }
                    break;
                    
                case 'displayStorms':
                    // Display multiple storms from Database tab
                    if (data.storms && data.storms.length > 0) {
                        clearMapLayers();
                        
                        // Display all storms on map
                        data.storms.forEach(storm => {
                            if (storm.lat && storm.lon) {
                                const color = getCategoryColor(storm.category);
                                const marker = L.circleMarker([storm.lat, storm.lon], {
                                    radius: 6 + (storm.category * 1.5),
                                    fillColor: color,
                                    color: '#fff',
                                    weight: 2,
                                    opacity: 1,
                                    fillOpacity: 0.8
                                }).addTo(map);
                                
                                marker.bindPopup(`
                                    <strong>${storm.name} (${storm.year})</strong><br>
                                    Category: ${storm.category}<br>
                                    Wind: ${storm.wind_mph} mph<br>
                                    ${storm.landfall_states ? 'States: ' + storm.landfall_states.join(', ') : ''}
                                `);
                            }
                        });
                        
                        // Show first storm details in panel
                        updateStormInfoPanel(data.storms[0]);
                        
                        console.log('Displaying', data.storms.length, 'storms from Database');
                    }
                    break;
            }
        });
        
        // Listen for AI Assistant filter messages
        window.addEventListener('message', function(event) {
            if (event.data && event.data.action === 'applyFilters') {
                console.log('Applying AI-suggested filters:', event.data.filters);
                const filters = event.data.filters;
                
                // Apply year filters
                if (filters.yearStart) {
                    document.getElementById('start-year').value = filters.yearStart;
                    currentStartYear = filters.yearStart;
                }
                if (filters.yearEnd) {
                    document.getElementById('end-year').value = filters.yearEnd;
                    currentEndYear = filters.yearEnd;
                }
                
                // Apply category filters
                if (filters.categories) {
                    document.querySelectorAll('input[name="category"]').forEach(cb => {
                        cb.checked = filters.categories.includes(cb.value);
                    });
                } else if (filters.category !== undefined) {
                    document.querySelectorAll('input[name="category"]').forEach(cb => {
                        cb.checked = cb.value == filters.category;
                    });
                }
                
                // Apply search filter
                if (filters.search) {
                    document.getElementById('storm-search').value = filters.search;
                }
                
                // Trigger filter update
                filterStorms();
            }
        });
    </script>
</body>
</html>